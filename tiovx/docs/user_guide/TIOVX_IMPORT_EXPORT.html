<!-- HTML header for doxygen 1.8.15-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>TIOVX User Guide: Import Reference and Export Reference Usage in TIOVX</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ti_logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">TIOVX User Guide
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('TIOVX_IMPORT_EXPORT.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Import Reference and Export Reference Usage in TIOVX </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>In order to further explain the usage of the <a class="el" href="group__group__tivx__reference.html#ga624fdc5a1923380d531aa5434ca9ee57">tivxReferenceImportHandle</a> and <a class="el" href="group__group__tivx__reference.html#gacaa37f6685888ea927b9ff199a2d3d50">tivxReferenceExportHandle</a> API's, several use cases are provided below. In particular, each of these use cases note when each <a class="elRef" doxygen="/home/dockeruser/psdk_installer_build_top_workarea/scratch_workarea/staging_area/tiovx/internal_docs/doxy_cfg_user_guide/openvx.tag:https://www.khronos.org/registry/OpenVX/specs/1.1/html/" href="https://www.khronos.org/registry/OpenVX/specs/1.1/html/dd/d90/group__group__reference.html#ga1a95c3bf180e49d4d1ecd64cb35f45a3">vx_reference</a> is in a safe state to release. Please also note the legend on the left side of the images to fully understand the separate blocks within the diagrams.</p>
<h1><a class="anchor" id="TIOVX_IMPORT_EXPORT_SCENARIO1"></a>
Use Case 1</h1>
<p>The first use case involves 2 <a class="elRef" doxygen="/home/dockeruser/psdk_installer_build_top_workarea/scratch_workarea/staging_area/tiovx/internal_docs/doxy_cfg_user_guide/openvx.tag:https://www.khronos.org/registry/OpenVX/specs/1.1/html/" href="https://www.khronos.org/registry/OpenVX/specs/1.1/html/dd/d90/group__group__reference.html#ga1a95c3bf180e49d4d1ecd64cb35f45a3">vx_reference</a> 's, one which already has a memory buffer allocated for the <a class="elRef" doxygen="/home/dockeruser/psdk_installer_build_top_workarea/scratch_workarea/staging_area/tiovx/internal_docs/doxy_cfg_user_guide/openvx.tag:https://www.khronos.org/registry/OpenVX/specs/1.1/html/" href="https://www.khronos.org/registry/OpenVX/specs/1.1/html/dd/d90/group__group__reference.html#ga1a95c3bf180e49d4d1ecd64cb35f45a3">vx_reference</a> and one which does not. (Note: please refer to <a class="el" href="TIOVX_MEMORY_MANAGEMENT.html">Memory Management in TIOVX</a> for more information on when memory buffer allocation occurs.) These use case diagrams describe how to successfully import the memory buffer from one <a class="elRef" doxygen="/home/dockeruser/psdk_installer_build_top_workarea/scratch_workarea/staging_area/tiovx/internal_docs/doxy_cfg_user_guide/openvx.tag:https://www.khronos.org/registry/OpenVX/specs/1.1/html/" href="https://www.khronos.org/registry/OpenVX/specs/1.1/html/dd/d90/group__group__reference.html#ga1a95c3bf180e49d4d1ecd64cb35f45a3">vx_reference</a> to the next without causing a memory leak.</p>
<p>The below image describes the initial state of this use case, with ref1 pointing to buf1 while ref2 does not yet point to a memory buffer.</p>
<div class="image">
<img src="scenario1_t1.png" alt="scenario1_t1.png" width="60%"/>
</div>
<p>The next step in this use case is to export the buf1 from ref1 first to the application, followed by an import of buf1 to ref2. This sequence is shown in the below diagram. Following this operation, ref2 will be pointing to buf1, while ref1 is also still pointing to buf1. The important point about this portion of the sequence is that neither ref1 nor ref2 should be released at this time, as it will cause the reference that is not released to be pointing to a buffer which has been released.</p>
<div class="image">
<img src="scenario1_t2.png" alt="scenario1_t2.png" width="60%"/>
</div>
<p>Now that the ref2 is pointing to buf1, the ref1 is no longer needed. The proper way to then release ref1 is to first import a NULL pointer to ref1 to ensure it is no longer pointing to buf1. Once this import is done, the ref2 can be used as required and both ref1 and ref2 are in a state that allows them to be released without a memory leak or invalid memory access.</p>
<div class="image">
<img src="scenario1_t3.png" alt="scenario1_t3.png" width="60%"/>
</div>
<h1><a class="anchor" id="TIOVX_IMPORT_EXPORT_SCENARIO2"></a>
Use Case 2</h1>
<p>The next use case involves 2 <a class="elRef" doxygen="/home/dockeruser/psdk_installer_build_top_workarea/scratch_workarea/staging_area/tiovx/internal_docs/doxy_cfg_user_guide/openvx.tag:https://www.khronos.org/registry/OpenVX/specs/1.1/html/" href="https://www.khronos.org/registry/OpenVX/specs/1.1/html/dd/d90/group__group__reference.html#ga1a95c3bf180e49d4d1ecd64cb35f45a3">vx_reference</a> 's, which both already have memory buffers allocated for each of the <a class="elRef" doxygen="/home/dockeruser/psdk_installer_build_top_workarea/scratch_workarea/staging_area/tiovx/internal_docs/doxy_cfg_user_guide/openvx.tag:https://www.khronos.org/registry/OpenVX/specs/1.1/html/" href="https://www.khronos.org/registry/OpenVX/specs/1.1/html/dd/d90/group__group__reference.html#ga1a95c3bf180e49d4d1ecd64cb35f45a3">vx_reference</a> 's. (Note: please refer to <a class="el" href="TIOVX_MEMORY_MANAGEMENT.html">Memory Management in TIOVX</a> for more information on when memory buffer allocation occurs.) These use case diagrams describe how to successfully import the memory buffer from one <a class="elRef" doxygen="/home/dockeruser/psdk_installer_build_top_workarea/scratch_workarea/staging_area/tiovx/internal_docs/doxy_cfg_user_guide/openvx.tag:https://www.khronos.org/registry/OpenVX/specs/1.1/html/" href="https://www.khronos.org/registry/OpenVX/specs/1.1/html/dd/d90/group__group__reference.html#ga1a95c3bf180e49d4d1ecd64cb35f45a3">vx_reference</a> to the next without causing a memory leak.</p>
<p>The below image describes the initial state of this use case, with ref1 pointing to buf1 and ref2 pointing to buf2.</p>
<div class="image">
<img src="scenario2_t1.png" alt="scenario2_t1.png" width="60%"/>
</div>
<p>Since we are ultimately trying to import buf1 to ref2, we first export buf2 from ref2. If instead we were to import another buffer directly to ref2 prior to this step of exporting buf2, the implementation will throw a <a class="el" href="group__group__vx__debug.html#gga73f8b7d2888a862fd66f8f479eead7e6a6b3ec6ddfa7a8fd71e010d4347667a5b">VX_ZONE_INFO</a> message indicating that we are overriding the buffer. In this case, this buffer will be lost and there will be a memory leak. Therefore, this step is needed to avoid such a scenario.</p>
<div class="image">
<img src="scenario2_t2.png" alt="scenario2_t2.png" width="60%"/>
</div>
<p>Similar to the previous use case, the next step is to export the buf1 from ref1 first to the application, followed by an import of buf1 to ref2 as shown in the below diagram. And similarly to the use case above, it should be noted that neither ref1 nor ref2 should be released at this time, as it will cause the reference that is not released to be pointing to a buffer which has been released.</p>
<div class="image">
<img src="scenario2_t3.png" alt="scenario2_t3.png" width="60%"/>
</div>
<p>The next step is to free buf2 obtained from the export from ref2 using the <a class="el" href="group__group__tivx__mem.html#gad87518b76fa2035d65385e24e1c2e502">tivxMemFree</a> API. This step can optionally be done before the preceding step without issue. However, while ref1 and ref2 are both pointing to buf1, these still cannot be released.</p>
<div class="image">
<img src="scenario2_t4.png" alt="scenario2_t4.png" width="60%"/>
</div>
<p>Finally, similarly to use case 1, in order to prepare ref1 for release, a NULL pointer can be imported to ref1. Once this import is done, the ref2 can be used as required and both ref1 and ref2 are in a state that allows them to be released without a memory leak or invalid memory access.</p>
<div class="image">
<img src="scenario2_t5.png" alt="scenario2_t5.png" width="60%"/>
</div>
<h1><a class="anchor" id="TIOVX_IMPORT_EXPORT_SCENARIO3"></a>
Use Case 3</h1>
<p>The next use case to consider is the case wherein you want to swap the buffers being pointed to by the references.</p>
<p>The below image describes the initial state of this use case, with ref1 pointing to buf1 and ref2 pointing to buf2.</p>
<div class="image">
<img src="scenario3_t1.png" alt="scenario3_t1.png" width="60%"/>
</div>
<p>The first step to achieve this swap is to initially export both buf1 from ref1 and buf2 from ref2.</p>
<div class="image">
<img src="scenario3_t2.png" alt="scenario3_t2.png" width="60%"/>
</div>
<p>These buffers are now available to be imported to the different references. In the diagram below, buf2 is imported into ref1, overriding buf1's association with ref1. At this point in the call sequence, the references are not in a state which allows them to be released properly.</p>
<div class="image">
<img src="scenario3_t3.png" alt="scenario3_t3.png" width="60%"/>
</div>
<p>Finally, the buf1 is imported into ref2, completing the swap. Once this import is done, both ref1 and ref2 are in a state that allows them to be released without a memory leak or invalid memory access.</p>
<div class="image">
<img src="scenario3_t4.png" alt="scenario3_t4.png" width="60%"/>
</div>
<h1><a class="anchor" id="TIOVX_IMPORT_EXPORT_SCENARIO4"></a>
Use Case 4</h1>
<p>The last use case considered here is the import of memory which has not been allocated via the framework directly via the data object constructors. The memory must still be allocated using the <a class="el" href="group__group__tivx__mem.html#ga99635ddb13baefecfbb1cf262437ca46">tivxMemAlloc</a> API as per the <a class="el" href="group__group__tivx__reference.html#ga624fdc5a1923380d531aa5434ca9ee57">tivxReferenceImportHandle</a> API documentation.</p>
<p>In the diagram below, the situation is such that a <a class="elRef" doxygen="/home/dockeruser/psdk_installer_build_top_workarea/scratch_workarea/staging_area/tiovx/internal_docs/doxy_cfg_user_guide/openvx.tag:https://www.khronos.org/registry/OpenVX/specs/1.1/html/" href="https://www.khronos.org/registry/OpenVX/specs/1.1/html/dd/d90/group__group__reference.html#ga1a95c3bf180e49d4d1ecd64cb35f45a3">vx_reference</a> has been created with no buffer yet allocated, while a separate buffer has been allocated using the <a class="el" href="group__group__tivx__mem.html#ga99635ddb13baefecfbb1cf262437ca46">tivxMemAlloc</a> API.</p>
<div class="image">
<img src="scenario4_t1.png" alt="scenario4_t1.png" width="60%"/>
</div>
<p>In order to have the ref1 point to this new buf1, the <a class="el" href="group__group__tivx__reference.html#ga624fdc5a1923380d531aa5434ca9ee57">tivxReferenceImportHandle</a> API can be called, creating the desired result of ref1 pointing to buf1. Now when the ref1 is released, the buf1 will also be freed.</p>
<div class="image">
<img src="scenario4_t2.png" alt="scenario4_t2.png" width="60%"/>
</div>
<h1><a class="anchor" id="TIOVX_IMPORT_EXPORT_SCENARIO5"></a>
Use Case 5</h1>
<p>One high level use case of this API is sharing the exported buffers across processes. The below set of diagrams describe how this can be achieved within a multi-process scenario. At a high level, the semantic which must be adhered to in this scenario is that the process which originally allocated the buffer must finally free the buffer.</p>
<p>First, let us consider two processes where we have created 2 OpenVX references where we ultimately want the OpenVX reference in each process to point to the same memory. In the first process, we have ensured the buffer has been allocated, while in the second we have an OpenVX reference pointing to a NULL buffer. (Note: if the reference in P2 has already been allocated, it must first be released similarly to <a class="el" href="TIOVX_IMPORT_EXPORT.html#TIOVX_IMPORT_EXPORT_SCENARIO2">Use Case 2</a>).</p>
<div class="image">
<img src="scenario5_t1.png" alt="scenario5_t1.png" width="60%"/>
</div>
<p>Next, we would like to export the buffer buf1 from ref1 across the process boundary to ref2. (Note: There are utility API's to do aid in this sharing of buffers across process boundaries. Please reference the "File Descriptor Exchange across Processes" application found within the vision apps package of the PSDK RTOS for an example on how to use these.) Internally to these API's, the physical buffer has now been shared across the process boundary and has been mmapped to the process. Depending on the application, there may now need to be further communication across the process boundary, particularly in the case that each of these references are graph parameters of graphs within the separate processes.</p>
<div class="image">
<img src="scenario5_t2.png" alt="scenario5_t2.png" width="60%"/>
</div>
<p>Once the application has completed, the sequence below must be followed for releasing these references. The consumer processs of the buffer (P2) can first release the reference "ref2". This in turn munmaps the buf1 from this process. Note that if this buf1 was shared across multiple references in P2, all but one of those references can have a NULL buffer imported to the reference and subsequently be released.</p>
<div class="image">
<img src="scenario5_t3.png" alt="scenario5_t3.png" width="60%"/>
</div>
<p>Now that buf1 has been munmapped from P2, the same communication mechanism established from P1 &lt;-&gt; P2 must signal back to P1 that the buffer has been munmapped from P2 and thus is ready to be ultimately freed from P1.</p>
<div class="image">
<img src="scenario5_t4.png" alt="scenario5_t4.png" width="60%"/>
</div>
<p>Now that P1 has received the signal from P2 that the buf1 has been munmapped, the buf1 is ready to be released. This can be done by releasing ref1, thereby freeing buf1.</p>
<div class="image">
<img src="scenario5_t5.png" alt="scenario5_t5.png" width="60%"/>
</div>
<p>It is important to note that within each process, the buffer handling and releasing adheres to the same semantic as described in the use cases above, namely that the actual release of the memory must be done a single time. For other references which received the imported buffer within the same process, the suggested process for release is that the reference has imported a NULL reference prior to release. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.15-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="REFERENCES.html">User Resources</a></li><li class="navelem"><a class="el" href="TIOVX_USAGE.html">TIOVX Usage</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.14 </li>
  </ul>
</div>
</body>
</html>
